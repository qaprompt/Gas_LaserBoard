#include "App_Include.h"

IrSpectrum_t st_IrSpectrum = {
    5,
    0,
    200,
    {0},
    {0},
    {0},
};


BOOL Mod_IRSpectrumPoll(IrSpectrum_t* pst_Spe)
{
    INT16U  i;

    if(++pst_Spe->uch_ScanCnt >= pst_Spe->uch_ScanAvg)
    {
        pst_Spe->uch_ScanCnt = 0;

        Mod_TransmissionPoll();                                                                      //计算透过率

        for(i = 0; i < pst_Spe->uin_SpectrumLen; i++) 
        {
            pst_Spe->af_ProceSpectrum[i] = pst_Spe->af_SumSpectrum[i]/pst_Spe->uch_ScanAvg;             //计算平均光谱
            /*还需要转换成电压单位 并除去 运放的放大倍数 才是实际的吸收峰 */
            
            pst_Spe->af_SumSpectrum[i] = 0;                                                             //清零求和光谱
        }

        for(i = 0; i < pst_Spe->uin_SpectrumLen; i++) 
        {
            //点斜率式 通过相似三角形算出f1 是三角波的直流分量
            FP32 f1 = (st_Trans.f_VoltMax - st_Trans.f_VoltMin) * i / pst_Spe->uin_SpectrumLen + st_Trans.f_VoltMin;
            FP32 f2 = 0; //过高通 //..f2 = str_Trans.f_DcCancelV;
            FP32 f_K = st_Trans.f_LightTrans;			//采样电压的差值 / 原始电压的差值，这是反应透过率大小的原始参数
            FP32 f_AverDc = 0;

            if(st_ModWave.f_TrgVpp >0 )													                //三角波幅值大于0
            {
                //最高点直流电压(采样电压) + 采样电压和原始电压的差值 * 透过率偏差值
                f_AverDc = f1 + f2 + f_K * st_Trans.f_OffestCompare;							        //透过率修正偏差值  假如实际接收到0.3v三角波 发射是0.9v三角波
            }
            else
            {
                f_AverDc = f2 +  f_K * st_Trans.f_OffestCompare;								        //透过率修正偏差值
            }
            
            pst_Spe->af_OriginalSpectrum[i] = pst_Spe->af_ProceSpectrum[i] / f_AverDc;                  //ac/dc 修正光谱透过率
        }
    }
    else
    {
        for(i = 0; i < pst_Spe->uin_SpectrumLen; i++) 
            pst_Spe->af_SumSpectrum[i] += pst_Spe->af_RawSpectrum[i];        //累计求和光谱
    }
    return TRUE;
}
