//==================================================================================================
//| 文件名称 |Mod_Transmission.cpp
//|--------- |--------------------------------------------------------------------------------------
//| 文件描述 | 透过率采用与计算
//|--------- |--------------------------------------------------------------------------------------
//| 运行环境 | 所有C/C++语言编译环境，包括单片机编译器
//|--------- |--------------------------------------------------------------------------------------
//| 版权声明 | Copyright2007, 聚光科技(FPI)
//|----------|--------------------------------------------------------------------------------------
//|  版本    |  时间       |  作者     | 描述
//|--------- |-------------|-----------|------------------------------------------------------------
//|  V1.0    | 2007.10.10  |  gao      | 初版
//==================================================================================================

#include "App_Include.h"



Transmission_t st_Trans = {
    0,
    0,
    0,
    
    -0.16,
    0,
    1.0,
    0,
    0,
    0,
};

void Mod_TransInit(void)
{
    st_Trans.uin_SampleCount = 0;
    st_Trans.ul_TransSumAD1 = 0;
    st_Trans.ul_TransSumAD2 = 0;
    
    st_Trans.f_LightTrans = 0;
    st_Trans.f_Transmission = 0;
    st_Trans.f_VoltMax = 0;
    st_Trans.f_VoltMin = 0;
}

//==================================================================================================
//| 函数名称 | s_SmapleAndAddTransmission1()
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 透过率1采样和累加(透过率上区间)
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无 
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|-------------------------------------------------------------------------------------- 
//| 函数设计 | gao,07.10.24
//==================================================================================================  
void Mod_TransSmapleHigh(void)
{
    FP32 f_Temp;
    f_Temp = Bsp_Ltc1867SampleAvg(eSignalDC,15);      //50次约3ms   10次约200us
    st_Trans.ul_TransSumAD1 += f_Temp;
}


//==================================================================================================
//| 函数名称 | s_SmapleAndAddTransmission2()
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 透过率2采样和累加(透过率下区间)
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无 
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|-------------------------------------------------------------------------------------- 
//| 函数设计 | gao,07.10.24
//==================================================================================================  
void Mod_TransSmapleLow(void)
{
    FP32 f_Temp;
    f_Temp = Bsp_Ltc1867SampleAvg(eSignalDC,15);       //50次约3ms  10次约200us
    st_Trans.ul_TransSumAD2 += f_Temp;
    st_Trans.uin_SampleCount++;
}

//==================================================================================================
//| 函数名称 | s_CalTransmission()
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 透过率计算
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无 
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 透过率状态标准位
//|----------|-------------------------------------------------------------------------------------- 
//| 函数设计 | gao,07.10.24
//==================================================================================================   
FP32 Mod_TransmissionPoll(void)
{
    FP32 f_Sub,f_Sub0;

    /* 发送波形的最高点和最低点之间的电压 */
	f_Sub0 = st_ModWave.puin_RiseBuff[0] - st_ModWave.puin_RiseBuff[st_ModWave.uin_SampleDot-1];
	f_Sub0 = -1.0f * Bsp_AD5546HexToVolt((INT16U)f_Sub0);

	if(st_Trans.ul_TransSumAD1 < st_Trans.ul_TransSumAD2)
    {
        INT32U temp = st_Trans.ul_TransSumAD1;
        st_Trans.ul_TransSumAD1 = st_Trans.ul_TransSumAD2;
        st_Trans.ul_TransSumAD2 = temp;
    }
    
    st_Trans.f_VoltMax = Bsp_Ltc1867HexToVolt((FP64)st_Trans.ul_TransSumAD1/st_Trans.uin_SampleCount);
    st_Trans.f_VoltMin = Bsp_Ltc1867HexToVolt((FP64)st_Trans.ul_TransSumAD2/st_Trans.uin_SampleCount);
        
    f_Sub = (st_Trans.ul_TransSumAD1 - st_Trans.ul_TransSumAD2)/(FP32)st_Trans.uin_SampleCount; 
	f_Sub  = Bsp_Ltc1867HexToVolt(f_Sub);       //转换成实际电压差

	st_Trans.f_LightTrans = f_Sub/f_Sub0;    //实际电压差值/理论电压差值
    

    st_Trans.f_Transmission = (st_Trans.f_LightTrans)*(1.6*st_Trans.f_TransK)*100.0;

    if (st_Trans.f_Transmission > 100)
   	{
   	   	st_Trans.f_Transmission=100;
	}				

    st_Trans.uin_SampleCount = 0;
    st_Trans.ul_TransSumAD1 = 0;
    st_Trans.ul_TransSumAD2 = 0;

	return st_Trans.f_Transmission;
}

void Mod_TransmissionClear(void)
{
    st_Trans.uin_SampleCount = 0;
    st_Trans.ul_TransSumAD1 = 0;
    st_Trans.ul_TransSumAD2 = 0;
}
